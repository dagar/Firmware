#!nsh
#
# Script to configure control interface
#
#
# NOTE: environment variable references:
#  If the dollar sign ('$') is followed by a left bracket ('{') then the
#  variable name is terminated with the right bracket character ('}').
#  Otherwise, the variable name goes to the end of the argument.
#

# OUTPUT DEVICE default
set OUTPUT_DEV /dev/pwm_output0

# Set default output if not set
if [ $OUTPUT_MODE == none ]
then
	if [ $USE_IO == yes ]
	then
		set OUTPUT_MODE io
	else
		set OUTPUT_MODE fmu
	fi
fi

if [ $OUTPUT_MODE == io -a $IO_PRESENT != yes ]
then
	# Need IO for output but it not present, disable output
	set OUTPUT_MODE none

	# Avoid using ttyS0 for MAVLink on FMUv1
	if ver hwcmp PX4FMU_V1
	then
		set FMU_MODE serial
	fi
fi

if [ $OUTPUT_MODE == ardrone ]
then
	set FMU_MODE gpio_serial
	ardrone_interface start -d /dev/ttyS1
fi

if [ $OUTPUT_MODE == tap_esc ]
then
	set FMU_MODE rcin
	set OUTPUT_DEV /dev/tap_esc
fi

# If OUTPUT_MODE == none then something is wrong with setup and we shouldn't try to enable output
if [ $OUTPUT_MODE != none ]
then
	if [ $OUTPUT_MODE == uavcan_esc ]
	then
		if param compare UAVCAN_ENABLE 0
		then
			echo "OVERRIDING UAVCAN_ENABLE = 3" >> $LOG_FILE
			param set UAVCAN_ENABLE 3
		fi
	fi

	if [ $OUTPUT_MODE == io -o $OUTPUT_MODE == uavcan_esc ]
	then
		if px4io start
		then
			sh /etc/init.d/rc.io
		else
			echo "PX4IO start failed" >> $LOG_FILE
			tone_alarm $TUNE_ERR
		fi
	fi

	if [ $OUTPUT_MODE == fmu -o $OUTPUT_MODE == ardrone ]
	then
		if fmu mode_$FMU_MODE
		then
		else
			echo "FMU start failed" >> $LOG_FILE
			tone_alarm $TUNE_ERR
		fi

		if ver hwcmp PX4FMU_V1
		then
			if [ $FMU_MODE == pwm -o $FMU_MODE == gpio ]
			then
				set TTYS1_BUSY yes
			fi
			if [ $FMU_MODE == pwm_gpio -o $OUTPUT_MODE == ardrone ]
			then
				set TTYS1_BUSY yes
			fi
		fi
	fi

	if [ $OUTPUT_MODE == mkblctrl ]
	then
		set OUTPUT_DEV /dev/mkblctrl0

		set MKBLCTRL_ARG ""
		if [ $MKBLCTRL_MODE == x ]
		then
			set MKBLCTRL_ARG "-mkmode x"
		fi
		if [ $MKBLCTRL_MODE == + ]
		then
			set MKBLCTRL_ARG "-mkmode +"
		fi

		if mkblctrl $MKBLCTRL_ARG
		then
		else
			echo "MK start failed" >> $LOG_FILE
			tone_alarm $TUNE_ERR
		fi
		unset MKBLCTRL_ARG
	fi
	unset MK_MODE

	if [ $OUTPUT_MODE == hil ]
	then
		if pwm_out_sim mode_pwm16
		then
		else
			tone_alarm $TUNE_ERR
		fi
	fi

	#
	# Start IO or FMU for RC PPM input if needed
	#
	if [ $IO_PRESENT == yes ]
	then
		if [ $OUTPUT_MODE != io ]
		then
			if px4io start
			then
				sh /etc/init.d/rc.io
			else
				echo "PX4IO start failed" >> $LOG_FILE
				tone_alarm $TUNE_ERR
			fi
		fi
	else
		if [ $OUTPUT_MODE != fmu -a $OUTPUT_MODE != ardrone ]
		then
			if fmu mode_${FMU_MODE}
			then
			else
				echo "FMU mode_${FMU_MODE} start failed" >> $LOG_FILE
				tone_alarm $TUNE_ERR
			fi

			if ver hwcmp PX4FMU_V1
			then
				if [ $FMU_MODE == pwm -o $FMU_MODE == gpio ]
				then
					set TTYS1_BUSY yes
				fi
				if [ $FMU_MODE == pwm_gpio -o $OUTPUT_MODE == ardrone ]
				then
					set TTYS1_BUSY yes
				fi
			fi
		fi
	fi
fi

set SDCARD_MIXERS_PATH /fs/microsd/etc/mixers

if [ $MIXER != none -a $MIXER != skip ]
then
	#
	# Load main mixer
	#

	if [ $MIXER_AUX == none -a $USE_IO == yes ]
	then
		set MIXER_AUX ${MIXER}
	fi

	# MIXER PATH
	# mixer preference order
	#  1. sdcard *.main.mix
	#  2. sdcard *.mix
	#  3. ${VEHICLE_TYPE}/${MIXER}.main.mix
	#  4. ${MIXER}.main.mix

	if [ -f /etc/mixers/${MIXER}.main.mix ]
	then
		set MIXER_FILE /etc/mixers/${MIXER}.main.mix
	fi

	if [ -f /etc/mixers/${VEHICLE_TYPE}/${MIXER}.main.mix ]
	then
		set MIXER_FILE /etc/mixers/${VEHICLE_TYPE}/${MIXER}.main.mix
	fi

	if [ -f ${SDCARD_MIXERS_PATH}/${MIXER}.mix ]
	then
		set MIXER_FILE ${SDCARD_MIXERS_PATH}/${MIXER}.mix
	fi

	if [ -f ${SDCARD_MIXERS_PATH}/${MIXER}.main.mix ]
	then
		set MIXER_FILE ${SDCARD_MIXERS_PATH}/${MIXER}.main.mix
	fi

	if [ $OUTPUT_MODE == uavcan_esc ]
	then
		set OUTPUT_DEV /dev/uavcan/esc
	fi

	if mixer load ${OUTPUT_DEV} ${MIXER_FILE}
	then
		echo "INFO  [init] Mixer: ${MIXER_FILE} on ${OUTPUT_DEV}"
	else
		echo "ERROR  [init] Failed loading mixer: ${MIXER_FILE}"
		echo "ERROR  [init] Failed loading mixer: ${MIXER_FILE}" >> $LOG_FILE
		tone_alarm ${TUNE_ERR}
	fi

	unset MIXER_FILE
else
	if [ $MIXER != skip ]
	then
		echo "ERROR  [init] Mixer undefined"
		echo "ERROR  [init] Mixer undefined" >> $LOG_FILE
		tone_alarm ${TUNE_ERR}
	fi
fi

if [ $OUTPUT_MODE == fmu -o $OUTPUT_MODE == io ]
then
	if [ $PWM_OUT != none ]
	then
		#
		# Set PWM output frequency
		#
		if [ $PWM_RATE != none ]
		then
			pwm rate -c ${PWM_OUT} -r ${PWM_RATE}
		fi

		#
		# Set disarmed, min and max PWM values
		#
		if [ $PWM_DISARMED != none ]
		then
			pwm disarmed -c ${PWM_OUT} -p ${PWM_DISARMED}
		fi
		if [ $PWM_MIN != none ]
		then
			pwm min -c ${PWM_OUT} -p ${PWM_MIN}
		fi
		if [ $PWM_MAX != none ]
		then
			pwm max -c ${PWM_OUT} -p ${PWM_MAX}
		fi
	fi

	if [ $FAILSAFE != none ]
	then
		pwm failsafe -d ${OUTPUT_DEV} ${FAILSAFE}
	fi
fi

#
# If mount (gimbal) control is enabled and output mode is AUX, set the aux
# mixer to mount (override the airframe-specific MIXER_AUX setting)
#
if param compare MNT_MODE_IN -1
then
else
	if param compare MNT_MODE_OUT 0
	then
		set MIXER_AUX mount
	fi
fi

# clear MIXER_AUX for boards with no AUX

if ver hwcmp PX4FMU_V1
then
	set MIXER_AUX none
fi

if ver hwcmp PX4FMU_V4
then
	set MIXER_AUX none
fi

if ver hwcmp PX4FMU_V5
then
	set MIXER_AUX none
fi

if ver hwcmp AEROFC_V1
then
	set MIXER_AUX none
fi

if ver hwcmp AEROFC_V1
then
	set MIXER_AUX none
fi

if ver hwcmp CRAZYFLIE
then
	set MIXER_AUX none
fi

# MindPX has no aux mixer
if ver hwcmp MINDPX_V2
then
	set MIXER_AUX none
fi

if [ $MIXER_AUX != none -a $AUX_MODE != none ]
then
	#
	# Load aux mixer
	#

	set MIXER_AUX_FILE none
	set OUTPUT_AUX_DEV /dev/pwm_output1

	if [ -f /etc/mixers/${MIXER_AUX}.aux.mix ]
	then
		set MIXER_AUX_FILE /etc/mixers/${MIXER_AUX}.aux.mix
	fi

	if [ -f /etc/mixers/${VEHICLE_TYPE}/${MIXER_AUX}.aux.mix ]
	then
		set MIXER_AUX_FILE /etc/mixers/${VEHICLE_TYPE}/${MIXER_AUX}.aux.mix
	fi

	if [ -f ${SDCARD_MIXERS_PATH}/${MIXER_AUX}.aux.mix ]
	then
		set MIXER_AUX_FILE ${SDCARD_MIXERS_PATH}/${MIXER_AUX}.aux.mix
	fi

	if [ $MIXER_AUX_FILE != none ]
	then
		if fmu mode_${AUX_MODE}
		then
			# Append aux mixer to main device
			if [ $OUTPUT_MODE == hil ]
			then
				if mixer append ${OUTPUT_DEV} ${MIXER_AUX_FILE}
				then
					echo "INFO  [init] Mixer: ${MIXER_AUX_FILE} appended to ${OUTPUT_DEV}"
				else
					echo "ERROR  [init] Failed appending mixer: ${MIXER_AUX_FILE}"
					echo "ERROR  [init] Failed appending mixer: ${MIXER_AUX_FILE}" >> $LOG_FILE
				fi
			fi
			if [ -e $OUTPUT_AUX_DEV -a $OUTPUT_MODE != hil ]
			then
				if mixer load ${OUTPUT_AUX_DEV} ${MIXER_AUX_FILE}
				then
					echo "INFO  [init] Mixer: ${MIXER_AUX_FILE} on ${OUTPUT_AUX_DEV}"
				else
					echo "ERROR  [init] Failed loading mixer: ${MIXER_AUX_FILE}"
					echo "ERROR  [init] Failed loading mixer: ${MIXER_AUX_FILE}" >> $LOG_FILE
				fi
			else
				set PWM_AUX_OUT none
				set FAILSAFE_AUX none
			fi
		else
			echo "ERROR: Could not start: fmu mode_pwm" >> $LOG_FILE
			tone_alarm ${TUNE_ERR}
			set PWM_AUX_OUT none
			set FAILSAFE_AUX none
		fi

		# Set min / max for aux out and rates
		if [ $PWM_AUX_OUT != none ]
		then
			#
			# Set PWM_AUX output frequency
			#
			if [ $PWM_AUX_RATE != none ]
			then
				pwm rate -c ${PWM_AUX_OUT} -r ${PWM_AUX_RATE} -d ${OUTPUT_AUX_DEV}
			fi

			if [ $PWM_AUX_MIN != none ]
			then
				pwm min -c ${PWM_AUX_OUT} -p ${PWM_AUX_MIN} -d ${OUTPUT_AUX_DEV}
			fi
			if [ $PWM_AUX_MAX != none ]
			then
				pwm max -c ${PWM_AUX_OUT} -p ${PWM_AUX_MAX} -d ${OUTPUT_AUX_DEV}
			fi
		fi

		# Set disarmed values for aux out

		# Transitional support until all configs
		# are updated
		if [ $PWM_ACHDIS == none ]
		then
			set PWM_ACHDIS ${PWM_AUX_OUT}
		fi

		#
		# Set disarmed, min and max PWM_AUX values
		#
		if [ $PWM_AUX_DISARMED != none -a $PWM_ACHDIS != none ]
		then
			pwm disarmed -c ${PWM_ACHDIS} -p ${PWM_AUX_DISARMED} -d ${OUTPUT_AUX_DEV}
		fi

		if [ $FAILSAFE_AUX != none ]
		then
			pwm failsafe -d ${OUTPUT_AUX_DEV} ${FAILSAFE}
		fi

	fi
fi

unset PWM_OUT
unset PWM_RATE
unset PWM_ACHDIS
unset PWM_MIN
unset PWM_MAX
unset PWM_AUX_OUT
unset PWM_AUX_RATE
unset PWM_AUX_DISARMED
unset PWM_AUX_MIN
unset PWM_AUX_MAX
unset FAILSAFE_AUX
unset FAILSAFE
unset OUTPUT_DEV
unset OUTPUT_AUX_DEV
