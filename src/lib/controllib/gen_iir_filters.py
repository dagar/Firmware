from __future__ import print_function, division
import jinja2
import scipy.signal
import numpy as np
import os
import sys
import matplotlib.pyplot as plt

SCRIPT_PATH = os.path.realpath(os.path.dirname(os.path.realpath(__file__)))

if scipy.__version__ < "0.19.0":
    raise AssertionError('need scipy >= 0.19.0 to support discrete filter design')

#######################################################
# FILTER_DESIGN

gp = 0.1 # maximum loss of 0.1 dB in pass band
max_sections = 3
filters = []


def uid_hash(name):
    # hashes the name of the filter into a 14 bit unsigned integer
    # probability of collision 
    return hash(name) % (2 ** 14)

for fs in [1000]:
    nyq = fs/2 # nyquist frequency
    uid_set = set()

    for wp_hz in [20, 40, 60]:

        ws_hz = int(wp_hz + 20)
        wp_norm = wp_hz/nyq
        ws_norm = ws_hz/nyq

        for gs in [20, 40]:

            for ftype in ['ellip', 'cheby2']:

                try:
                    sos = scipy.signal.iirdesign(wp=wp_norm, ws=ws_norm,
                        gpass=gp, gstop=gs, analog=False, ftype=ftype, output='sos')
                    num, den = scipy.signal.iirdesign(wp=wp_norm, ws=ws_norm,
                        gpass=gp, gstop=gs, analog=False, ftype=ftype, output='ba')
                    tf = scipy.signal.TransferFunction(num, den, dt=1.0/fs)
                except Exception as e:
                    print(e)
                    continue
                name = 'LowPass_{ftype:s}_{fs:d}fs_{wp_hz:d}' \
                'wp_{ws_hz:d}ws_{gs:d}gs'.format(
                        **locals())

                if len(sos) > max_sections:
                    print('too many section ({:d}), skipping {:s}'.format(len(sos), name))
                    continue
                else:
                    print('generating', name)

                uid = uid_hash(name)
                if uid in uid_set:
                    raise AssertionError('hash collision on filter name', name)
                uid_set.add(uid)
                filters += [{
                    'uid': uid,
                    'name': name,
                    'sos': sos,
                    'tf': tf,
                    'wp_hz': wp_hz,
                    'ws_hz': ws_hz,
                    'fs': fs,
                    'ftype': ftype,
                    'gs': gs,
                    'gp': gp,
                    'n': 3,
                }]

#######################################################
# PLOTTING

def bode_comparison(filters):

    plt.subplot(211)
    for i, f in enumerate(filters):
        ftype = f['ftype']
        wp_hz = f['wp_hz']
        ws_hz = f['ws_hz']
        w = np.logspace(1, 3, 1000)
        w, mag, phase = f['tf'].bode(w/f['fs'])
        w = w/(2*np.pi)
        label = '{:s} SENS_IMU_LP = {:d}'.format(f['name'], f['uid'])
        plt.semilogx(w, mag, label=label, linewidth=3)

    plt.title('magnitude')
    plt.grid(which='both')
    plt.xlabel('Hz')
    plt.ylabel('dB')
    plt.legend(loc='best')
    plt.xlabel('frequency, Hz')
    plt.ylabel('amplitude, dB')

    plt.subplot(212)
    for i, f in enumerate(filters):
        ftype = f['ftype']
        wp_hz = f['wp_hz']
        ws_hz = f['ws_hz']
        w = np.logspace(1, 3, 1000)
        w, mag, phase = f['tf'].bode(w/f['fs'])
        w = w/(2*np.pi)
        label = '{:s} SENS_IMU_LP = {:d}'.format(f['name'], f['uid'])
        plt.semilogx(w, phase, label=label, linewidth=3)

    plt.title('phase')
    plt.grid(which='both')
    plt.xlabel('frequency, Hz')
    plt.ylabel('phase, deg')

f_plot = {
    '20': [],
    '40': [],
    '60': []
}
for f in filters:
    if f['wp_hz'] < 21:
        f_plot['20'] += [f]
    elif f['wp_hz'] < 41:
        f_plot['40'] += [f]
    elif f['wp_hz'] < 61:
        f_plot['60'] += [f]
    else:
        f_plot['61+'] += [f]

for key in f_plot.keys():
    plt.figure(figsize=(10, 10))
    bode_comparison(f_plot[key])
    plt.savefig('bode_iir_filter_{:s}_passband.png'.format(key))


#######################################################
# TEMPLATES

header = """// generated by gen_iir_filters.py, DO NOT EDIT

#include <controllib/BiQuad.hpp>
#include <matrix/math.hpp>

enum filter_t {
{%- for filt in filters %}
	FILT_{{ filt.name | upper }} = {{ filt.uid }}{% if loop.index != filters | length %},{% endif %}
{%- endfor %}
};

namespace control
{

template<size_t N>
class Filter
{
public:
	virtual matrix::Vector<float, N> update(matrix::Vector<float, N> x);
	virtual ~Filter() {};
};

{% for filt in filters %}
template<size_t N>
class Filter_{{ filt.name | upper }} : public Filter<N>
{
public:
	Filter_{{ filt.name | upper }}() :
		{%- for s in filt.sos %}
		{#- note a0 is always 1, so s[3] is skipped #}
		_s_{{ loop.index0 }}({{ s[0] }}, {{ s[1] }}, {{ s[2] }}, {{ s[4] }}, {{ s[5] }})
		{%- if loop.index != filt.sos | length -%}
		,
		{%- endif -%}
		{% endfor %}
	{
	}

	virtual ~Filter_{{ filt.name | upper }}() {};

	virtual matrix::Vector<float, N> update(matrix::Vector<float, N> x)
	{
	{%- for s in filt.sos %}
		x = _s_{{ loop.index0 }}.update(x);
	{%- endfor %}
		return x;
	};
private:
	{%- for s in filt.sos %}
	control::BiQuad<float, N> _s_{{ loop.index0 }};
	{%- endfor %}
};
{% endfor %}


template<size_t N>
Filter<N> *new_filter(filter_t type)
{
	{%- for filt in filters -%}
	{%- if loop.index0 == 0 %}
	if (type == FILT_{{ filt.name | upper }}) {
	{%- else %}
	} else if (type == FILT_{{ filt.name | upper }}) {
	{%- endif %}
		return new Filter_{{ filt.name | upper }}<N>();
{% endfor %}
	} else {
		return nullptr;

	}

}

} // namespace control
"""


#######################################################
# SOURCE GENERATION

def generate(data, outdir):
    """
    :param data: is a dict of data for the tempalte to render.
        -filters - list of filters
            - sos - array of floats, second order sections (n x 6)
              (4 th number must be 1), a0 coefficient is normalized
    :param outdir: output directory
    """
    # assert normalized biquad
    for filt in data['filters']:
        for s in filt['sos']:
            if s[3] != 1:
                raise AssertionError('s[3] must always be 1, got', s[3])

    with open(os.path.join(outdir, 'iir_filters.h'), 'w') as f:
        f.write(jinja2.Environment().from_string(header).render(data))

generate({'filters': filters}, SCRIPT_PATH)
